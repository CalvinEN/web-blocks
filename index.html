<!doctype html>
<html>
<head>
    <title>Web Blocks</title>

    <link href="build/app.css" rel="stylesheet" type="text/css" />

    <script src="lib/underscore.js"></script>
    <script src="lib/three.v71.js"></script>

    <script src="lib/StereoEffect.js"></script>
    <script src="lib/DeviceOrientationControls.js"></script>
    <script src="lib/OrbitControls.js"></script>

    <script src="build/external.js"></script>
    <script src="build/app.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">

attribute vec3 offset;
attribute float data;

uniform sampler2D info;
uniform float time;

varying vec3 vPos;
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 vOffset;
varying float vData;

varying float vType;
varying float vSide;
varying float vShade;

void main() {
  vNormal = normal;
  vUv = uv;
  vOffset = offset;
  vData = data;

  float on = 1.0;

  if (on >= 1.0) {
    vec3 newPosition = position;

    vPos = (modelMatrix * vec4(newPosition, 1.0)).xyz;

    vType = floor(mod(vData, 256.0));
    vSide = floor(mod(vData / 256.0, 256.0));
    vShade = floor(vData / 65536.0);

    if (vType == 3.0) {
        vPos.y += sin(time / 3.0) / 2.0 - 0.5;
    }

    /*if (vType == 1.0) {
        //vPos.x += sin((vPos.y + vPos.x) / 4.0 + time / 3.0) * 20.0;
        vPos.x += sin((vPos.z + vPos.x + vPos.y) / 4.0 + time / 3.0) * 5.0;
        vPos.y += cos((vPos.z + vPos.x + vPos.y) / 4.0 + time / 3.0) * 5.0;
        vPos.z += sin((vPos.z + vPos.x + vPos.y) / 4.0 + time / 3.0) * 5.0;
    }*/

    gl_Position = projectionMatrix * viewMatrix * vec4(vPos, 1.0);
  } else {
    gl_Position = vec4(0.0, 0.0, 0.0, 0.0);
  }
}

    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

uniform sampler2D grass[4];
uniform sampler2D info;

uniform vec3 ambientLightColor;

uniform vec3 pointLightColor[MAX_POINT_LIGHTS];
uniform vec3 pointLightPosition[MAX_POINT_LIGHTS];
uniform float pointLightDistance[MAX_POINT_LIGHTS];

uniform float time;

varying vec3 vPos;
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 vOffset;
varying float vData;

varying float vType;
varying float vSide;
varying float vShade;

uniform vec3 fogColor;

void main() {
  vec2 uv = vUv;

  float isSide = 0.0;

  if (vSide == 0.0 || vSide == 1.0 || vSide == 4.0 || vSide == 5.0) {
    isSide = 1.0;
  }

  // Number of textures per cube
  float sideCount = 8.0;

  // Number block types
  float typeCount = 8.0;

  uv.x = uv.x * (1.0 / sideCount) + isSide * (1.0 / sideCount);
  uv.y = uv.y * (1.0 / typeCount) + vType * (1.0 / typeCount);

  //// Force stone texture only
  //uv.x = uv.x / 8.0;
  //uv.y = uv.y / 8.0 + (1.0 / 8.0);

  vec4 col = texture2D(info, uv);

  // Pretty basic lambertian lighting...
  vec4 addedLights = vec4(0.0, 0.0, 0.0, 1.0);

  for (int l = 0; l < MAX_POINT_LIGHTS; l++) {
    vec3 lightDirection = normalize(vPos - pointLightPosition[l]);
    addedLights.rgb += clamp(dot(-lightDirection, vNormal), 0.0, 1.0) * pointLightColor[l];
  }

  gl_FragColor = col * (addedLights + vec4(ambientLightColor, 1.0));

  float fog = min(1.0, pow((gl_FragCoord.z / gl_FragCoord.w) / 96.0, 1.5));

  //float sky = (vPos.y / 32.0);
  //float ground = 1.0 - (vPos.y / 32.0);
  //
  //vec3 fogCol = vec3(1.0, 1.0, 1.0) * ground + vec3(0.7333, 0.8, 1.0) * sky;

// Only top face has shade
  if (vSide == 2.0) {
    gl_FragColor = gl_FragColor * (1.0 - (vShade / 255.0));
  }

  gl_FragColor = gl_FragColor * (1.0 - fog) + vec4(fogColor, 0.0) * fog;

  /*if (vType == 1.0) {
    gl_FragColor.r += sin(time + vPos.x);
    gl_FragColor.g += sin(time + vPos.y);
    gl_FragColor.b += sin(time + vPos.z);
  }*/

  //gl_FragColor = vec4(vPos, 1.0);

  //gl_FragColor.r = sin(vAbsPos.x);
}

    </script>

    <script>
        'use strict';

        window.blockMovement = false;

        window.addEventListener('load', function() {
            bootstrap(document.body);
        });

        function bootstrap(container) {
            var app = new App();

            app.init(container);
        }
    </script>
</head>
<body>


</body>
</html>
